# iOS 多线程

### 1. GCD

> 引自 [百度百科](https://link.juejin.cn/?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FGCD) **Grand Central Dispatch（GCD）** 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。

**那为什么我们要使用 GCD 呢？**

因为使用 GCD 有很多好处啊，具体如下：

- GCD 可用于多核的并行运算；
- GCD 会自动利用更多的 CPU 内核（比如双核、四核）；
- GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；
- 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。

GCD 拥有以上这么多的好处，而且在多线程中处于举足轻重的地位。那么我们就很有必要系统地学习一下 GCD 的使用方法。

### 2. GCD中的任务和队列

> GCD 直译就是大型中央调度（系统），调度的基本单元就是 task（在 OC 中就是一个 block），用户只用将相应的 task  挂载（submit）到相应的 queue，GCD 就会依据 queue 的类型和信息进行集中调度，用户不用关心底层线程调度。Dispatch queue 上的 task 执行遵循先进先出（FIFO）的原则。
>
> Dispatch queue 分为两种，一种是串行队列，task 要顺序执行，一种是并发队列，task 会并发执行。如图。
>
> 先来了解 GCD 中两个核心概念：**『任务/task』** 和 **『队列/queue』**。

**任务**：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：**『同步执行』** 和 **『异步执行』**。两者的主要区别是：**是否等待队列的任务执行结束，以及是否具备开启新线程的能力。**

- 同步执行（sync）：
  - 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
  - 只能在当前线程中执行任务，不具备开启新线程的能力。
- 异步执行（async）：
  - 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
  - 可以在新的线程中执行任务，具备开启新线程的能力。

### 3. GCD使用方法

GCD 的使用步骤其实很简单，只有两步：

1. 创建一个队列（串行队列或并发队列）；
2. 将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。

#### 3.1 队列的创建方法 / 获取方法

- 可以使用

  ```
dispatch_queue_create
  ```
  
  方法来创建队列。该方法需要传入两个参数：

  - 第一个参数表示队列的唯一标识符，用于 DEBUG，可为空。队列的名称推荐使用应用程序 ID 这种逆序全程域名。
- 第二个参数用来识别是串行队列还是并发队列。`DISPATCH_QUEUE_SERIAL` 表示串行队列，`DISPATCH_QUEUE_CONCURRENT` 表示并发队列。

```objc
// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT);
复制代码
```

- 对于串行队列，GCD 默认提供了：

  『主队列（Main Dispatch Queue）』

  所有放在主队列中的任务，都会放到主线程中执行。
- 可使用 `dispatch_get_main_queue()` 方法获得主队列。

> 注意：**主队列其实并不特殊。** 主队列的实质上就是一个普通的串行队列，只是因为默认情况下，当前代码是放在主队列中的，然后主队列中的代码，又都会放到主线程中去执行，所以才造成了主队列特殊的现象。

```objc
// 主队列的获取方法
dispatch_queue_t queue = dispatch_get_main_queue();
```

- 对于并发队列，GCD 默认提供了

   

  『全局并发队列（Global Dispatch Queue）』

  。

  - 可以使用 `dispatch_get_global_queue` 方法来获取全局并发队列。需要传入两个参数。第一个参数表示队列优先级，一般用 `DISPATCH_QUEUE_PRIORITY_DEFAULT`。第二个参数暂时没用，用 `0` 即可。

```objc
// 全局并发队列的获取方法
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
```

#### 3.2 任务的创建方法

GCD 提供了同步执行任务的创建方法 `dispatch_sync` 和异步执行任务创建方法 `dispatch_async`。

```objc
// 同步执行任务创建方法
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
// 异步执行任务创建方法
dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});
```

#### 3.3 任务和队列不同组合方式的区别

我们先来考虑最基本的使用，也就是当前线程为 **『主线程』** 的环境下，**『不同队列』+『不同任务』** 简单组合使用的不同区别。暂时不考虑 **『队列中嵌套队列』** 的这种复杂情况。

**『主线程』\**中，\**『不同队列』**+**『不同任务』**简单组合的区别：

| 区别          | 并发队列                     | 串行队列                          | 主队列                       |
| ------------- | ---------------------------- | --------------------------------- | ---------------------------- |
| 同步（sync）  | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务      | 死锁卡住不执行               |
| 异步（async） | 有开启新线程，并发执行任务   | 有开启新线程（1条），串行执行任务 | 没有开启新线程，串行执行任务 |

> 注意：从上边可看出： **『主线程』** 中调用 **『主队列』+『同步执行』** 会导致死锁问题。 这是因为 **主队列中追加的同步任务** 和 **主线程本身的任务** 两者之间相互等待，阻塞了 **『主队列』**，最终造成了主队列所在的线程（主线程）死锁问题。 而如果我们在 **『其他线程』** 调用 **『主队列』+『同步执行』**，则不会阻塞 **『主队列』**，自然也不会造成死锁问题。最终的结果是：**不会开启新线程，串行执行任务**。

#### 3.4 队列嵌套情况下，不同组合方式区别

- 『异步执行 + 并发队列』就是：系统开启了多个线程（主线程+其他子线程），任务可以多个同时运行。
- 『同步执行 + 并发队列』就是：系统只默认开启了一个主线程，没有开启子线程，虽然任务处于并发队列中，但也只能一个接一个执行了。



https://juejin.cn/post/6844903566398717960#heading-27