# 性能优化

### 1. 优化指标

1. 渲染

- 滑动流畅度：FPS，即Frame per Second，一秒内的刷新帧数，越接近60帧越好；
- 过度绘制：单页面的3X（粉红色区域） Overdraw小于25%
- 启动时间：这里主要说的是Activity界面启动时间，一般低于300ms，需要用高频摄像机计算时间。

2. 内存

- 内存大小：峰值越低越好，需要优化前后做对比
- 内存泄漏：需要用工具检查对比优化前后

3. 功耗

- 单位时间内的掉电量，掉电量越少越好，业内没有固定标准。华为有专门测试功耗的机器，以及自己的标准。



### 2. 问题分类

1. 渲染问题： 过度绘制、布局冗杂
2. 内存问题： 内存浪费（内存管理）、内存泄漏
3. 功耗问题： 耗电
4. APK 体积
5. 网络优化



### 3. 渲染问题

#### 3.1 常见原因

1. 人为在UI线程中做轻微耗时操作，导致UI线程卡顿；
2. 布局Layout过于复杂，无法在16ms内完成渲染；
3. 同一时间动画执行的次数过多，导致CPU或GPU负载过重；
4. View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；
5. View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；
6. 内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；
7. 冗余资源及逻辑等导致加载和执行缓慢；
8. 臭名昭著的ANR；

#### 3.2 过度绘制

1. 移除或修改Window默认的Background
2. **移除XML布局文件中非必需的Background**
3. 按需显示占位背景图片
4. 控制绘制区域（自定义View中通过clipRect() 控制每次刷新的区域）

#### 3.3 布局优化

- 可以使用相对布局减少层级的就使用相对布局，否则使用线性布局。Android中RelativeLayout和LinearLayout性能分析
- 用merge标签来合并布局，这可以减少布局层次。
- 用include标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了，但要避免include乱用。
- **避免创建不必要的布局层级。（最容易发生的！）**
- 使用惰性控件ViewStub实现布局动态加载

### 4. 内存问题

#### 4.1 内存浪费

- ArrayMap
- 避免 AutoBoxing
- SparseArray
- 避免使用 Enum

#### 4.2 内存泄露

### ![img](https://f.wetest.qq.com/gqop/10000/20000/LabImage_5e6ca0237b69d1941b7e56c08e127315.png)

- 单例（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放）
- 静态变量（同样也是因为生命周期比较长）
- Handler内存泄露
- 匿名内部类（匿名内部类会引用外部类，导致无法释放，比如各种回调）
- 资源使用完未关闭（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap）

#### 4.3 图片资源分辨率

举个例子，对于一张1280×720的图片，如果放在xhdpi，那么xhdpi的设备拿到的大小还是1280×720而xxhpi的设备拿到的可能是1920×1080，这两种情况在内存里的大小分别为：3.68M和8.29M，相差4.61M，在移动设备来说这几M的差距还是很大的。

#### 4.4 图片压缩

BitmapFactory.Options

#### 4.5 缓存池大小

默认缓存池设置太大了会导致浪费内存，设置小了又会导致图片经常被回收，所以需要根据每个App的情况，以及设备的分辨率，内存计算出一个比较合理的初始值，可以参考Glide的做法。

#### 4.6 内存抖动

一个很经典的案例是string拼接创建大量小的对象(比如在一些频繁调用的地方打字符串拼接的log的时候)

#### 4.7 其他

- **数据结构优化**。ArrayMap及SparseArray是android的系统API，是专门为移动设备而定制的。用于在一定情况下取代HashMap而达到节省内存的目的,具体性能见HashMap，ArrayMap，SparseArray源码分析及性能对比[10]，对于key为int的HashMap尽量使用SparceArray替代，大概可以省30%的内存，而对于其他类型，ArrayMap对内存的节省实际并不明显，10%左右，但是数据量在1000以上时，查找速度可能会变慢。
- **枚举**，Android平台上枚举是比较争议的，在较早的Android版本，使用枚举会导致包过大，在个例子里面，使用枚举甚至比直接使用int包的size大了10多倍 在stackoverflow上也有很多的讨论, 大致意思是随着虚拟机的优化，目前枚举变量在Android平台性能问题已经不大，而目前Android官方建议，使用枚举变量还是需要谨慎，因为枚举变量可能比直接用int多使用2倍的内存。
- **ListView复用**，这个大家都知道，getView里尽量复用conertView,同时因为getView会频繁调用，要避免频繁地生成对象
- **谨慎使用多进程**，现在很多App都不是单进程，为了保活，或者提高稳定性都会进行一些进程拆分，而实际上即使是空进程也会占用内存(1M左右)，对于使用完的进程，服务都要及时进行回收。
- **尽量使用系统资源**，系统组件，图片甚至控件的id
- **减少view的层级**，对于可以 延迟初始化的页面，使用viewstub
- **数据相关**：序列化数据使用protobuf可以比xml省30%内存，慎用shareprefercnce，因为对于同一个sp，会将整个xml文件载入内存，有时候为了读一个配置，就会将几百k的数据读进内存，[数据库](http://lib.csdn.net/base/14)字段尽量精简，只读取所需字段。
- **dex优化**，代码优化，谨慎使用外部库， 有人觉得代码多少于内存没有关系，实际会有那么点关系，现在稍微大一点的项目动辄就是百万行代码以上，多dex也是常态，不仅占用rom空间，实际上运行的时候需要加载dex也是会占用内存的(几M)，有时候为了使用一些库里的某个功能函数就引入了整个庞大的库，此时可以考虑抽取必要部分，开启proguard优化代码，使用Facebook redex使用优化dex(好像有不少坑)



### 5. APK 体积

| 文件/目录           | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| lib/                | 存放so文件，可能会有armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips，大多数情况下只需要支持armabi与x86的架构即可，如果非必需，可以考虑拿掉x86的部分 |
| res/                | 存放编译后的资源文件，例如：drawable、layout等等             |
| assets/             | 应用程序的资源，应用程序可以使用AssetManager来检索该资源     |
| META-INF/           | 该文件夹一般存放于已经签名的APK中，它包含了APK中所有文件的签名摘要等信息 |
| classes(n).dex      | classes文件是Java Class，被DEX编译后可供Dalvik/ART虚拟机所理解的文件格式 |
| resources.arsc      | 编译后的二进制资源文件                                       |
| AndroidManifest.xml | Android的清单文件，格式为AXML，用于描述应用程序的名称、版本、所需权限、注册的四大组件 |

#### 5.1 图片优化

- WebP

- 矢量图。

  系统渲染每个VectorDrawable对象需要大量的时间，较大的图像需要更长的时间才能出现在屏幕上。 因此只有在显示小图像时才考虑使用矢量图形。

#### 5.2 代码优化

- 慎用三方SDK
- 代码混淆



### 6 网络优化

#### 6.1 序列化与反序列化



#### 6.2 DNS解析



#### 6.3 QUIC



#### 6.4 弱网优化



------

[]: http://www.androidchina.net/8612.html	"几乎是史上最全最实用的Android性能全面分析与优化方案研究"



