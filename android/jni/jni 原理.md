# JNI原理



![img](https://www.luoxudong.com/wp-content/uploads/2018/04/20180416110407_51811.png)

### 1. 步骤

#### 1.1 编写 Java 文件中的 native 方法

```java
public class Test{
        static{
                System.loadLibrary("bridge");
        }

        public native int nativeAdd(int x,int y);

        public static void main(String[] args){
                Test obj = new Test();
                System.out.printf("%d\n",obj.nativeAdd(2012,3));
        }
}
```



#### 1.2 生成JNI调用需要的头文件

```shell
javac hackooo/Test.java 
javah -jni hackooo.Test
```

头文件内容：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class hackooo_Test */

#ifndef _Included_hackooo_Test
#define _Included_hackooo_Test
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     hackooo_Test
 * Method:    nativeAdd
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_hackooo_Test_nativeAdd
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```



#### 1.3 native 方法的实现

bridge.c 的实现：

```c
#include "hackooo_Test.h"

JNIEXPORT jint JNICALL Java_hackooo_Test_nativeAdd 
(JNIEnv * env, jobject obj, jint x, jint y){
        return x+y;
}
```



#### 1.5 生成动态链接库

```shell
gcc -shared -I /usr/lib/jdk1.6.0_45/include 
-I /usr/lib/jdk1.6.0_45/include/linux bridge.c -o libbridge.so
```

注意这里几个gcc的选项，-shared是说明要生成动态库，而两个 -I的选项，是因为我们用到<jni.h>相关的头文件，放在<jdk>/include 和 <jdk>/include/linux两个目录下。 

最后需要注意一点的是 -o 选项，我们在java代码中调用的是System.loadLibrary("xxx"),那么生成的动态链接库的名称就必须是libxxx.so的形式（这里指Linux环境），否则在执行java代码的时候，就会报 java.lang.UnsatisfiedLinkError: no XXX in java.library.path 的错误。

### 2. 源码中的 JNI

#### 2.1 静态注册

静态注册的原理是先由JAVA代码编写需要调用的接口什么，然后通过JNI实现这些声明方法。
比较通用的做法是先创建一个java文件，声明需要使用JNI实现的接口，然后使用javah命令生成对应的C/C++头文件。再一一实现头文件中的函数即可。JAVA层调用JIN函数时，会从对应的JNI文件中查找该函数，因此需要把JAVA层接口和Native函数建立一层关联，静态注册的实现方法就是在Native函数命名上遵守特定的格式，否则就会找不到对应函数而报错。

#### 2.2 动态注册

动态注册的原理是在JNI层通过重载JNI_OnLoad()函数来实现。
针对静态注册的缺点，动态注册方法就可以避免。动态注册的原理是通过RegisterNatives方法把C/C++函数映射到JAVA定义的方法，不需要通过JAVA方法名查找匹配Native函数名，也就不需要遵循静态注册的命名规则。

#### 2.3 JNI注册的两种时机：

- Android系统启动过程中Zygote注册，可通过查询AndroidRuntime.cpp中的gRegJNI，看看是否存在对应的register方法；
- 调用System.loadLibrary()方式注册。

### 实现原理

将刚刚的 Java 文件编译成 class 文件：

```java
 public native int nativeAdd(int, int);
    flags: ACC_PUBLIC, ACC_NATIVE

  public int add(int, int);
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1       
         1: iload_2       
         2: iadd          
         3: ireturn       
      LineNumberTable:
        line 8: 0
```

普通的“add”方法是直接把字节码放到code属性表中，而native方法，与普通的方法通过一个标志“ACC_NATIVE”区分开来。

### System.loadLibrary()

简单的说，dlopen、dlsym提供一种动态转载库到内存的机制，在需要的时候，可以调用库中的方法。

- 调用`dlopen`函数，打开一个so文件并创建一个handle；
- 调用`dlsym()`函数，查看相应so文件的`JNI_OnLoad()`函数指针，并执行相应函数。

dlopen相当于打开一个共享库，打开的时候可以使用RTLD_LAZY标志，等函数真正被调用的时候才去装载库。dlopen返回一个handle,这个句柄是使用其它的dlxxx函数用的，dlsym就是使用dlopen返回的handle，去查找相应的符号，然后返回相应的函数指针的。

总之，System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad() 方法。


### 总结
Java动态装载共享库，靠的是系统的 “dlxxx” 相关的函数实现的。对于装载的共享库，java虚拟机，也会有缓存，在装载共享库的时候，会读取共享库的header，并且解析并保存里面的符号表，当调用native方法的时候，用刚才的例子中提到的方法进行调用。



------

[]: http://gityuan.com/2016/05/28/android-jni/	"Android JNI原理分析"

