# jni引用

### 0. 简介

在 Native 代码中有时候会接收 Java 传入的引用类型参数，有时候也会通过 NewObject 方法来创建一个 Java 的引用类型变量。

在编写 Native 代码时，要注意这个代表 Java 数据结构类型的引用在使用时会被 GC 回收的可能性。

Native 代码并不能直接通过引用来访问其内部的数据接口，必须要通过调用 JNI 接口来间接操作这些引用对象，就如在之前的系列文章中写的那样。并且 JNI 还提供了和 Java 相对应的引用类型，因此，我们就需要通过管理好这些引用来管理 Java 对象，避免在使用时被 GC 回收了。

JNI 提供了三种引用类型：

- 局部引用
- 全局引用
- 弱全局引用

### 1. 局部引用

局部引用是最常见的一种引用。绝大多数 JNI 函数创建的都是局部引用，比如：NewObject、FindClass、NewObjectArray 函数等等。

> 局部引用会阻止 GC 回收所引用的对象，同时，它不能在本地函数中跨函数传递，不能跨线程使用。

局部引用在 Native 函数返回后，所引用的对象会被 GC 自动回收，也可以通过 DeleteLocalRef 函数来手动回收。

在之前文章 JNI 调用时缓存字段和方法 ID，第一种方法采用的是使用时缓存，把字段 ID 通过 static 变量缓存起来。

如果把 FindClass 函数创建的局部引用也通过 static 变量缓存起来，那么在函数退出后，局部引用被自动释放了，static 静态变量中存储的就是一个被释放后的内存地址，成为了一个野指针，再次调用时就会引起程序崩溃了。

### 2. 全局引用

> 全局引用和局部引用一样，也会阻止它所引用的对象被回收。但是它不会在方法返回时被自动释放，必须要通过手动释放才行，而且，全局引用可以跨方法、跨线程使用。

全局引用只能通过 `NewGlobalRef`函数来创建，然后通过 `DeleteGlobalRef` 函数来手动释放。

还是上面提到的缓存字段的例子，现在就可以使用全局引用来缓存了。

### 3. 弱全局引用

> 弱全局引用有点类似于 Java 中的弱引用，它所引用的对象可以被 GC 回收，并且它也可以跨方法、跨线程使用。

弱引用使用 `NewWeakGlobalRef` 方法创建，使用 `DeleteWeakGlobalRef` 方法释放。

### 4. 合理管理引用

总结一些关于引用管理方面的知识点，可以减少内存的使用和避免因为对象被引用不能释放而造成的内存浪费。

通常来说，Native 代码大体有两种情况：

- 直接实现 Java 层声明的 Native 函数的代码
- 用在任何场景下的工具函数

对于直接实现 Java 层声明的 Native 函数，不要造成全局引用和弱全局引用的累加，因为它们在函数返回后并不会自动释放。

对于工具类的 Native 函数，由于它的调用场合和次数是不确定的，所以要格外小心各种引用类型，避免造成累积而导致内存溢出，比如如下规则：

- 返回基础类型的 Native 工具函数，不能造成全局引用、弱全局引用、局部引用的积累。
- 返回引用类型的 Native 工具函数，除了要返回的引用之外，也不能造成任何的全局引用、弱全局引用、局部引用的积累。