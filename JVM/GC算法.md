

# cGC 算法

### 1. 垃圾回收算法介绍

1. 标记回收算法（Mark and Sweep GC）从”`GC Roots`”集合开始，将内存整个遍历一次，保留所有可以被 `GC Roots` 直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，过程分两步。
   1. Mark 标记阶段：找到内存中的所有 GC Root 对象，只要是和 GC Root 对象直接或者间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）。
   2. Sweep 清除阶段：当遍历完所有的 GC Root 之后，则将标记为垃圾的对象直接清除。



![标记清除算法](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debab099380c4ee3b911a8f9b0af2adc~tplv-k3u1fbpfcp-watermark.image)



- 优点：实现简单，不需要将对象进行移动。
- 缺点：这个算法需要中断进程内其他组件的执行（stop the world），并且可能产生内存碎片，提高了垃圾回收的频率。



2. 复制算法 (Copying）
   将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的**内存中的存活对象复制到未被使用的内存块**中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。



3. 标记-压缩算法 (Mark-Compact)
   先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。



4. 分代算法
   将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-压缩算法。



#### 区别

乍一看这两个算法似乎并没有多大的区别，都是标记了然后挪到另外的内存地址进行回收，那为什么不同的分代要使用不同的回收算法呢？

其实2者最大的区别在于**前者是用空间换时间后者则是用时间换空间**。

前者的在工作的时候是不没有独立的“mark”与“copy”阶段的，而是合在一起做一个动作，就叫scavenge（或evacuate，或者就叫copy）。也就是说，每发现一个这次收集中尚未访问过的活对象就直接copy到新地方，同时设置forwarding pointer。这样的工作方式就需要多一份空间。

后者在工作的时候则需要分别的mark与compact阶段，mark阶段用来发现并标记所有活的对象，然后compact阶段才移动对象来达到compact的目的。如果compact方式是sliding compaction，则在mark之后就可以按顺序一个个对象“滑动”到空间的某一侧。因为已经先遍历了整个空间里的对象图，知道所有的活对象了，所以移动的时候就可以在同一个空间内而不需要多一份空间。

所以新生代的回收会更快一点，老年代的回收则会需要更长时间，同时压缩阶段是会暂停应用的，所以给我们应该尽量避免对象出现在老年代。

### 

### 2. 垃圾检出算法



### 1.引用计数法：

给一个对象添加引用计数器，每当有一个地方引用它，计数器就加一，引用失效就减一。好了，问题来了，如果我有两个对象互相引用，除此之外没有其他任何对象引用他们，实际上这两个对象已经无法访问，即我们说的垃圾对象。但他们互相引用，计数不为0，所以无法回收。这就是引用计数法的缺陷。

### 2.可达性分析算法（也叫根搜索算法）：

以根集对象为起始点进行搜索，如果有对象不可达的话，即为垃圾对象。

那些点可以作为GC Roots呢？一般来说，如下情况的对象可以作为GC Roots：

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI（Native方法）的引用的对象 

总之，JVM在做垃圾回收的时候，会检查堆中的所有对象是否被这些根集中的对象所引用，不能够被引用的对象就会被垃圾回收器回收。



